import * as colors from "https://deno.land/std@0.198.0/fmt/colors.ts"
import * as path from "https://deno.land/std@0.198.0/path/mod.ts"
import * as fs from "https://deno.land/std@0.198.0/fs/mod.ts"
import { grantOrThrow } from "https://deno.land/std@0.198.0/permissions/mod.ts"

import { error, info } from "./log.ts"

const TRACKWAY_REPO = "ssh://git@github.com/brokad/trackway"

export function ask(question: string): "yes" | "no" {
    const ans = prompt(`${colors.bold(colors.cyan("install:"))} ${question} [Y/n]`)
    if (!(ans === "y" || ans === "Y" || ans === null)) {
        return "no"
    } else {
        return "yes"
    }
}

type Platform = {
    machine: string,
    os: string
}

async function doUname(): Promise<Platform> {
    const cmd = new Deno.Command("uname", {
        args: ["-sm"]
    })
    const stdout = (await cmd.output()).stdout
    const output = new TextDecoder().decode(stdout)
    const [os, machine] = output.toLowerCase().split(" ")
    return {
        machine,
        os
    }
}

async function resolveLatestRelease(): Promise<URL> {
    const { machine, os } = await doUname()
    return new URL(`https://github.com/brokad/trackway/releases/latest/download/trackway-${os}-${machine}`)
}

async function donwloadLatestRelease() {
    const github_bin_url = await resolveLatestRelease()

    const home = Deno.env.get("HOME")

    if (home === undefined) throw new Error("could not locate home")

    const bin_target_path = path.join(home, ".local/bin/trackwayc")
    const bin_target_dir = path.dirname(bin_target_path)

    await fs.ensureDir(bin_target_dir)

    const resp = await fetch(new Request(github_bin_url, {
        redirect: "follow"
    }))

    if (resp.status != 200) {
        error(`could not download trackwayc: ${resp.statusText}`)
        return
    }

    info(`downloading ${github_bin_url}`)

    const f = await Deno.open(bin_target_path, {
        write: true,
        create: true,
    })

    await resp.body?.pipeTo(f.writable)

    await Deno.chmod(bin_target_path, 0o755)
}

async function runCargoInstall() {
    try {
        const cmd = new Deno.Command("cargo", {
            args: ["install", "--bin=trackwayc", `--git=${TRACKWAY_REPO}.git`]
        })
        if (!(await cmd.spawn().status).success) {
            error("cargo seems to have exited unsuccessfully, things may not work as expected")
        }
    } catch (e) {
        if (e instanceof Deno.errors.NotFound) {
            error("couldn't find a Rust toolchain")
            error("read more here: https://www.rust-lang.org/tools/install")
        }
        throw e
    }
}

async function doBootstrap() {
    error("could not find trackwayc (a required Rust companion binary)")

    if (ask("Do you want to build trackwayc from source now?") != "yes")
        return

    await runCargoInstall()

    if(await isAvailable()) {
        info("ready to run ðŸŽ‰")
    } else {
        error("Couldn't make sure trackwayc is available: is it in your $PATH?")
        error("Try running:")
        error("    export PATH=$HOME/.cargo/bin:$HOME/.local/bin:$PATH")
    }
}

type RunParameters = {
    exec?: string
    output_path?: string,
    urls?: URL[],
    should_prompt?: boolean
}

export function doRun(params?: RunParameters): Deno.ChildProcess {
    let args = []
    let stdout: "inherit" | "piped" = "inherit"

    if (params?.output_path !== undefined) {
        args.push(`-o=${params.output_path}`)
    } else {
        stdout = "piped"
    }

    if (params?.urls !== undefined) {
        args.push(...params.urls.map(url => url.toString()))
    }

    const cmd = new Deno.Command(params?.exec || "trackwayc", {
        args,
        stdout,
        stderr: "inherit"
    })

    return cmd.spawn()
}

async function ensurePermissionsToRun(params?: RunParameters) {
    const permissions: Deno.PermissionDescriptor[] = [{
        name: "run",
        command: "trackwayc"
    }, {
        name: "net",
        host: "api.openai.com"
    }, {
        name: "read",
        path: "./"
    }, {
        name: "write",
        path: "./"
    }, {
        name: "env",
        variable: "OPENAI_KEY"
    }]

    const should_prompt = params?.should_prompt || true

    let missing_perms = false
    for (const permission of permissions) {
        const permission_status = await Deno.permissions.query(permission)
        missing_perms = missing_perms || permission_status.state != "granted"
    }

    if (missing_perms && should_prompt) {
        info("we need to run with the following permissions:")
        info(`  ${colors.bold("run")}        : to run trackwayc, a companion native binary which generates prompt files`)
        info(`  ${colors.bold("read/write")} : to manipulate prompt files generated by trackwayc`)
        info(`  ${colors.bold("env")}        : to read the value of the OPENAI_KEY environment variable`)
        info(`  ${colors.bold("net")}        : to interact with OpenAI's API`)
        await grantOrThrow(permissions)
    }
}

async function havePermissionsToRun(params?: RunParameters): Promise<boolean> {
    return ensurePermissionsToRun(params).then(() => true).catch(() => false)
}

async function isAvailable(params?: RunParameters): Promise<boolean> {
    let child

    try {
        child = doRun({ exec: params?.exec })
    } catch (e) {
        if (e instanceof Deno.errors.NotFound) {
            return false
        } else {
            throw e
        }
    }

    return child?.status?.then((status) => status.success) || false
}

if (await havePermissionsToRun() && !await isAvailable()) {
    await doBootstrap()
}
